---
title: "Run meta-clustering on cross-species data"
author: "Zhiyuan"
date: "9/15/2020 (last modified: `r Sys.Date()`)"
output: 
  prettydoc::html_pretty:
    theme: architect
    highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, fig.width = 12, fig.keep = TRUE, fig.path = "../plots/pancreas_twospecies/metaclustering/Rmarkdown_")
knitr::opts_knit$set(root.dir = "~/OneDrive - Nexus365/Project ClinCluster/evaluate-integration/evaluate-integration")

library(Seurat)
library(batchelor)
library(scater)
library(scran)
library(SingleCellExperiment)

library(limma)
library(reticulate)
library(edgeR)
library(doParallel)

library(igraph)
library(geomnet)
library(mclust)

library(ggplot2)
library(cowplot)
library(RColorBrewer)

source("~/OneDrive - Nexus365/Project ClinCluster/evaluate-integration/evaluate-integration/functions_simulate.R")
source("~/OneDrive - Nexus365/Project ClinCluster/evaluate-integration/evaluate-integration/functions_pipelines.R")
source("~/OneDrive - Nexus365/Project ClinCluster/evaluate-integration/evaluate-integration/functions_initial.R")


verbose <- FALSE
dirsave <- "pancreas_twospecies"
internal_cutoff <- 0.6
external_cutoff <- 0.45
n.cores <- detectCores(logical = FALSE) - 1 # number of cores

n <- 60
qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))
```

# Summary

# Preprocessing

```{r read-data}
seu <- readRDS(paste0("rdata/",dirsave,"/seurat_object_preprocessed.rds"))
anno <- read.delim("raw_data/pancreas_twospecies/41587_2018_BFnbt4096_MOESM62_ESM.txt", skip = 2)
sum(colnames(seu) %in% anno$Cell_Name )
```

# Benchmark metrics

A dataframe to record ARI

```{r create-df_ari}
df_ari <- data.frame(method = c("ours_denovo","ours_assisted","cca","mnn","scanorama","harmony", "seurat","sc3","raceid"), 
                     ARI = NA,
                     batch_ARI = NA,
                     runtime = 0)
clustering_res <- data.frame(cell = colnames(seu),
                             batch = seu$Batch,
                             label = seu$Group,
                             ours_denovo = NA,
                             ours_assisted = NA,
                             cca  = NA,
                             mnn  = NA,
                             scan = NA,
                             harmony = NA,
                             seurat = NA,
                             sc3 = NA,
                             raceid = NA)
```


# Pipeline 1: de novo clustering

## Initial clustering

```{r initial-clustering}
runtime_tmp <- system.time({
  seu_list <- Seurat::SplitObject(seu, split.by = "Batch")
  p_list <- list()
  for(i in 1:length(seu_list)){
    seu_list[[i]] <- NormalizeData(seu_list[[i]], normalization.method = "LogNormalize", scale.factor = 10000, verbose = verbose)
    seu_list[[i]] <- FindVariableFeatures(seu_list[[i]], selection.method = "vst", nfeatures = 2000, verbose = verbose)
    seu_list[[i]] <- ScaleData(seu_list[[i]], verbose = verbose, vars.to.regress = "sample")
    seu_list[[i]] <- RunPCA(seu_list[[i]], features = VariableFeatures(object = seu_list[[i]]), verbose = verbose)  
    seu_list[[i]] <- FindNeighbors(seu_list[[i]], dims = 1:15, verbose = verbose)
    seu_list[[i]] <- FindClusters(seu_list[[i]], resolution = 0.6, verbose = verbose)
    seu_list[[i]] <- RunTSNE(seu_list[[i]], dims = 1:15)
    p_list[[i]] <- DimPlot(seu_list[[i]], reduction = "tsne")
  }
})
df_ari$runtime[df_ari$method == "ours_denovo"] <- df_ari$runtime[df_ari$method == "ours_denovo"] + runtime_tmp[3]

plot_grid(plotlist = p_list)
```

```{r}
knitr::kable(table(seu_list[[2]]$Group, seu_list[[2]]$seurat_clusters))
```



## Pre-merge

```{r seu-batch1}
runtime_tmp <- system.time({
  dist_p <- list()
  dist_t <- list()
  dist_coef <- list()
  
  n_size <- 50
  
  for(seu_itor in 1:length(seu_list)){
    
    df_info <- data.frame(V1 = seu_list[[seu_itor]]@reductions$tsne@cell.embeddings[,1],
                          V2 = seu_list[[seu_itor]]@reductions$tsne@cell.embeddings[,2],
                          label = seu_list[[seu_itor]]$seurat_clusters,
                          batch = seu_list[[seu_itor]]$Batch,
                          donor = seu_list[[seu_itor]]$sample)
    idx <- downsampling(metadata = df_info, n_size = n_size, include = TRUE, replace = TRUE)
    idx <- sort(idx)
    
    to_add <-  idx[duplicated(idx)]
    idx <- idx[!duplicated(idx)] 
    matrix <- as.matrix(seu_list[[seu_itor]]@assays$RNA@counts[,idx])
    if(length(to_add) > 0) {
      matrix2 <- data.frame(seu_list[[seu_itor]]@assays$RNA@counts[,to_add])
      colnames(matrix2) <- paste0(colnames(matrix2), 1:ncol(matrix2))
      matrix2 <- as.matrix(matrix2)
      matrix <- cbind(matrix, matrix2)
      rm(matrix2)
    }
    
    if(length(unique(df_info$label[idx])) > 2) {
      dist_list <- calculateDistMatOneModel(matrix = matrix, metadata = df_info[c(idx, to_add),], 
                                            downsampling_factor = 1, verbose = verbose, method = "trend")
      dist_coef[[seu_itor]] <- dist_list[[1]]
      dist_t[[seu_itor]] <- dist_list[[2]]
      dist_p[[seu_itor]] <- dist_list[[3]]
    }
    
  }
})
df_ari$runtime[df_ari$method == "ours_denovo"] <- df_ari$runtime[df_ari$method == "ours_denovo"] + runtime_tmp[3]
```


```{r batch1-dist-heatmap}
par(mfrow = c(length(seu_list),1))
for(i in which(sapply(dist_p, function(x) return(!is.null(x))))){
  tmp <- dist_coef[[i]] + t(dist_coef[[i]])
  diag(tmp) <- 1
  pheatmap::pheatmap(tmp, display_numbers = TRUE)
}
```

```{r}
i=2
plot(hclust(1-as.dist(dist_coef[[i]] + t(dist_coef[[i]])), method = "average"))
```

```{r create-initialclusters}
df_ari$runtime[df_ari$method == "ours_denovo"] <- df_ari$runtime[df_ari$method == "ours_denovo"] + system.time({
  for(seu_itor in 1:2){
    tmp <- dist_coef[[seu_itor]] + t(dist_coef[[seu_itor]])
    diag(tmp) <- 1
    tmp <- 1 - tmp
    hc <- hclust(as.dist(tmp), method = "average")
    hres <- cutree(hc, h = 0.4)
    df_hres <- data.frame(hres)
    df_hres$hres <- paste0(df_hres$hres, "_", unique(seu_list[[seu_itor]]$Batch))
    seu_list[[seu_itor]]$inicluster_tmp <- paste0(seu_list[[seu_itor]]$seurat_clusters, "_", seu_list[[seu_itor]]$Batch)
    seu_list[[seu_itor]]$inicluster <- df_hres$hres[match(seu_list[[seu_itor]]$inicluster_tmp,rownames(df_hres))]
    
    table(seu_list[[seu_itor]]$inicluster, seu_list[[seu_itor]]$Group)
  }
  
}) [3]
```

```{r mouse-clusters, fig.width=12, fig.height=3}
i <- 1
p1 <- DimPlot(seu_list[[i]], reduction = "tsne", group.by = "inicluster")
p2 <- DimPlot(seu_list[[i]], reduction = "tsne", group.by = "Group")
p3 <-  DimPlot(seu_list[[i]], reduction = "tsne", group.by = "sample")
p1 + p2 + p3
```

```{r human-clusters, fig.width=12, fig.height=3}
i <- 2
p1 <- DimPlot(seu_list[[i]], reduction = "tsne", group.by = "inicluster")
p2 <- DimPlot(seu_list[[i]], reduction = "tsne", group.by = "Group")
p3 <-  DimPlot(seu_list[[i]], reduction = "tsne", group.by = "sample")
p1 + p2 + p3
```

## DE analysis

Composition of clusters

```{r table-cluster-composition}
## collect initial cluster labels
df_ari$runtime[df_ari$method == "ours_denovo"] <- df_ari$runtime[df_ari$method == "ours_denovo"] + system.time({
  tmp <- c()
  tmp_names <- c()
  for(seu_itor in 1:length(seu_list)) {
    tmp <- c(tmp, seu_list[[seu_itor]]$inicluster)
    tmp_names <- c(tmp_names,colnames(seu_list[[seu_itor]]))
  }
  
  metadata <- data.frame(label = tmp[match(colnames(seu), tmp_names)],
                         batch = seu$Batch,
                         ground_truth = seu$Group,
                         V1 = seu@reductions$tsne@cell.embeddings[,1],
                         V2 = seu@reductions$tsne@cell.embeddings[,2], stringsAsFactors = FALSE)
  
})[3]
knitr::kable(table(metadata$label, metadata$ground_truth))
```

```{r view-initial-clusters-for-DE, fig.height=15}
df_ari$runtime[df_ari$method == "ours_denovo"] <- df_ari$runtime[df_ari$method == "ours_denovo"] + system.time({
  n_size <- 35
  select <- downsampling(metadata = metadata, n_size = n_size, include = TRUE, replace = TRUE)
  
  matrix <- as.matrix(seu@assays$RNA@counts[,select])
  colnames(matrix) <- paste0(colnames(matrix),1:ncol(matrix))
  keep <- rowSums(matrix > 0.5) > 5 
  dge <- edgeR::DGEList(counts = matrix[keep,,drop=F]) # make a edgeR object
  dge <- dge[!grepl("ERCC-", rownames(dge)),] # remove ERCC
  dge <- dge[!grepl("MT-", rownames(dge)),]
  # rm(matrix, keep)
  
  df <- data.frame(g = metadata$label[select],
                   b = metadata$batch[select], ## batch
                   ground_truth = metadata$ground_truth[select],
                   stringsAsFactors = F) ## label
  df$detrate <- colSums(matrix > 0.5)
  rownames(df) <- colnames(matrix)
  
  N <- length(unique(df$g))
  
  combinations <- data.frame(g1 = rep(unique(df$g), each = N), g2 = rep(unique(df$g), N), stringsAsFactors = FALSE)
  combinations <- combinations[combinations$g1 != combinations$g2, ]
  combinations$b1 <- df$b[match(combinations$g1, df$g)]
  combinations$b2 <- df$b[match(combinations$g2, df$g)]
  combinations <- combinations[combinations$b1!=combinations$b2,]
  idx <- c()
  for(i in 2:nrow(combinations)){
    if(!combinations$g2[i] %in% combinations$g1[1:(i-1)]) {
      idx <- c(idx, i)
    }
  }
  
  combinations <- combinations[c(1,idx),]
  rownames(combinations) <- 1:nrow(combinations)
  
dist_p <- dist_coef <- matrix(0, nrow = N, ncol = N)
  colnames(dist_p) <- rownames(dist_p) <- unique(df$g)
  colnames(dist_coef) <- rownames(dist_coef) <- unique(df$g)
  cl <- makeCluster(n.cores) # initialize for parallel computation
  registerDoParallel(cl)
  n.iter <- nrow(combinations) # number of iterations
  
  i <- NULL
  j <- NULL
  
  df_dist <- foreach(i = combinations$g1, j = combinations$g2, df = rep(list(df), n.iter), 
                     dge = rep(list(dge), n.iter), .combine = "rbind") %dopar% 
    {
      library(limma)
      
      df$tmp <- "bg"
      df$tmp[df$g == i] <- "g1"
      df$tmp[df$g == j] <- "g2"
      
      ## design and contrast
      design <- model.matrix(~  0 + tmp + b + detrate, data = df) 
      contrast_m <- limma::makeContrasts(
        contrasts = c("tmpg1-tmpbg", "tmpg2-tmpbg"),
        levels = design
      )
      
      group_fit <- getGroupFit(dge, design, contrast_m, method = "trend")
      dist_coef_i <- cor(coef(group_fit)[, 1], coef(group_fit)[, 2])
      dist_p_i    <- cor(-log10(group_fit$p.value)[, 1] * sign(coef(group_fit)[, 1]), 
                         -log10(group_fit$p.value)[, 2] * sign(coef(group_fit)[, 2]))
      print(c(dist_coef_i, dist_p_i))
      
    }
  stopCluster(cl)
  for (i in 1:nrow(combinations)) {
    idx1 <- rownames(dist_coef) == combinations$g1[i]
    idx2 <- colnames(dist_coef) == combinations$g2[i]
    dist_coef[idx1, idx2] <- df_dist[i, 1]
    dist_p   [idx1, idx2] <- df_dist[i, 2]
  }
  
})[3]
```

## Final clustering

```{r final-clustering-match-names}
df_ari$runtime[df_ari$method == "ours_denovo"] <- df_ari$runtime[df_ari$method == "ours_denovo"] + system.time({
  hc <- hclust(as.dist(1-(dist_coef + t(dist_coef)))/2)
  hcluster <- cutree(hc, h = 0.35)
  df_merge <-  data.frame(initial_clusters = names(hcluster),
                          final_clusters = hcluster)
  
  seu$inicluster <- metadata$label
  seu$final_cluster <- df_merge$final_cluster[match(seu$inicluster,df_merge$initial_clusters)]
  seu$final_cluster[is.na(seu$final_cluster)] <- seu$inicluster[is.na(seu$final_cluster)]
})[3]

# record ARIs
df_ari$ARI[df_ari$method == "ours_denovo"] <- mclust::adjustedRandIndex(seu$final_cluster, seu$Group)
df_ari$batch_ARI[df_ari$method == "ours_denovo"] <- mclust::adjustedRandIndex(seu$final_cluster, seu$Batch)
clustering_res$ours_denovo <- seu$final_cluster[match(clustering_res$cell, colnames(seu))]
rm(seu_list)

knitr::kable(table(seu$final_cluster, seu$Group))
```

```{r final-clustering-network, fig.width=5, fig.height=5}
df <- data.frame(g = metadata$ground_truth[select],
                 b = metadata$batch[select], ## batch
                 c = metadata$label[select], stringsAsFactors = F) ## label

df$combination <- paste0(df$g, "-", df$c)
freq <- table(df$combination)
df$freq <- freq[match(df$combination, names(freq))]
df <- df[order(df$freq, decreasing = TRUE),]
df <- unique(df)

N <- length(unique(df$g))

edges <- data.frame(from = combinations$g1, to = combinations$g2, weight = NA)

tmp <- dist_coef + t(dist_coef)
for(i in 1:nrow(edges)) {
  edges$weight[i] <- tmp[rownames(tmp) == edges$from[i], colnames(tmp) == edges$to[i]]
}

edges$weight[edges$weight < 0] <- 0
edges <- edges[edges$weight > 0, ]
net <- graph_from_data_frame(edges, directed = FALSE)
E(net)$width <- 2^(E(net)$weight * 7)
vg_names <- attr(V(net), "names")
df_cols <- data.frame(group = unique(df$g),
                      col = col_vector[1:length(unique(df$g))], stringsAsFactors = FALSE)
df$col <- df_cols$col[match(df$g, df_cols$group)]

V(net)$color <- df$col[match(vg_names, df$c)]
V(net)$frame.color <- "#777777"
V(net)$size <- 10
V(net)$label.family <- "Helvetica"

plot(net);legend(x=-1.5, y=-1.1, df_cols$group, pch=21,
       col="#777777", pt.bg=df_cols$col, pt.cex=2, cex=.6, bty="n", ncol=1)
```

```{r hirerchical-tree}
plot(hclust(as.dist(1-(dist_coef + t(dist_coef)))/2))
```



# Pipeline 2: using prior annotations


## DE analysis



```{r pipeline2-DE, fig.height=15}
df_ari$runtime[df_ari$method == "ours_assisted"] <- df_ari$runtime[df_ari$method == "ours_assisted"] + system.time({
  
  metadata <- data.frame(label = paste(seu$Group, seu$Batch, sep = "_"),
                       batch = seu$Batch,
                       ground_truth = seu$Group,
                       V1 = seu@reductions$tsne@cell.embeddings[,1],
                       V2 = seu@reductions$tsne@cell.embeddings[,2], stringsAsFactors = FALSE)

  n_size <- 35
  select <- downsampling(metadata = metadata, n_size = n_size, include = TRUE, replace = TRUE)

  matrix <- as.matrix(seu@assays$RNA@counts[,select])
  colnames(matrix) <- paste0(colnames(matrix), "_", 1:ncol(matrix))
  keep <- rowSums(matrix > 0.5) > 5 
  dge <- edgeR::DGEList(counts = matrix[keep,,drop=F]) # make a edgeR object
  dge <- dge[!grepl("ERCC-", rownames(dge)),] # remove ERCC
  dge <- dge[!grepl("MT-", rownames(dge)),]
  # rm(matrix, keep)
  
  df <- data.frame(g = metadata$label[select],
                   b = metadata$batch[select], ## batch
                   ground_truth = metadata$ground_truth[select],
                   stringsAsFactors = F) ## label
  df$detrate <- scale(colMeans(matrix > 0))[,1]
  rownames(df) <- colnames(matrix)
  
  N <- length(unique(df$g)) # prepare pair information
  combinations <- data.frame(g1 = rep(unique(df$g), each = N), 
                             g2 = rep(unique(df$g), N), 
                             stringsAsFactors = FALSE)
  # remove pairs of the same group
  combinations <- combinations[combinations$g1 != combinations$g2, ]
  # remove pairs from the same batch
  combinations$b1 <- df$b[match(combinations$g1, df$g)]
  combinations$b2 <- df$b[match(combinations$g2, df$g)]
  combinations <- combinations[combinations$b1!=combinations$b2,]
  
  idx <- c() # remove redundent pairs (order switches)
  for(i in 2:nrow(combinations)){
    if(!combinations$g2[i] %in% combinations$g1[1:(i-1)]) {
      idx <- c(idx, i)
    }
  }
  
  combinations <- combinations[c(1,idx),]
  rownames(combinations) <- 1:nrow(combinations)
  dist_p <- dist_coef <- matrix(0, nrow = N, ncol = N)
  colnames(dist_p) <- rownames(dist_p) <- unique(df$g)
  colnames(dist_coef) <- rownames(dist_coef) <- unique(df$g)
  rm(matrix, keep)
  
  cl <- makeCluster(n.cores)
  registerDoParallel(cl)
  # showConnections()
  n.iter <- nrow(combinations) # number of iterations
  i <- NULL
  j <- NULL
  
  df_dist <- foreach(i = combinations$g1, j = combinations$g2, df = rep(list(df), n.iter), 
                     dge = rep(list(dge), n.iter), .combine = "rbind") %dopar% 
    {
      library(limma)
      df$tmp <- "bg"
      df$tmp[df$g == i] <- "g1"
      df$tmp[df$g == j] <- "g2"
      # design # contrast
      design <- model.matrix(~  0 + tmp + b + detrate, data = df)  
      contrast_m <- makeContrasts(contrasts = c("tmpg1-tmpbg", "tmpg2-tmpbg"), levels = design)
      group_fit <- getGroupFit(dge, design, contrast_m, method = "trend") # limma trend
      dist_coef_i <- cor(coef(group_fit)[, 1], coef(group_fit)[, 2])
      dist_p_i    <- cor(-log10(group_fit$p.value)[, 1] * sign(coef(group_fit)[, 1]), 
                         -log10(group_fit$p.value)[, 2] * sign(coef(group_fit)[, 2]))
      print(c(dist_coef_i, dist_p_i))
    }
  
  stopCluster(cl)
  for (i in 1:nrow(combinations)) {
    idx1 <- rownames(dist_coef) == combinations$g1[i]
    idx2 <- colnames(dist_coef) == combinations$g2[i]
    dist_coef[idx1, idx2] <- df_dist[i, 1]
    dist_p   [idx1, idx2] <- df_dist[i, 2]
  }
  
})[3]
```


```{r}
# dist_lst <- calculateIDER.multiModels(matrix = matrix, metadata = metadata, verbose = TRUE, method = "trend")
# dist_lst2 <- calculateIDER.multiModels(matrix = matrix, metadata = metadata, verbose = TRUE, method = "voom")
```

## Intepretability check

### Ductal

```{r Intepretability-ductal}
i <- which(combinations$g1 == "ductal_mouse" & combinations$g2 == "ductal_human")
df$tmp <- "bg"
df$tmp[df$g == combinations$g1[i]] <- "g1"
df$tmp[df$g == combinations$g2[i]] <- "g2"

design <- model.matrix(~  0 + tmp + b + detrate, data = df) # design  
contrast_m <- makeContrasts(contrasts = c("tmpg1-tmpbg", "tmpg2-tmpbg"), levels = design) # contrast

logCPM <- cpm(dge, log = TRUE, prior.count = 3)
fit <- lmFit(logCPM, design)
group_fit <- contrasts.fit(fit, contrast_m)
group_fit <- eBayes(group_fit, trend=TRUE, robust = TRUE)

df_res <- data.frame(gene = rownames(group_fit), coef_hu = coef(group_fit)[,2], coef_ms = coef(group_fit)[,1])
# Refer to https://rpubs.com/iabrady/residual-analysis
fit <- lm(coef_ms ~ coef_hu, data = df_res) 
df_res$predicted <- predict(fit)   
df_res$residuals <- residuals(fit) 
df_res$label <- FALSE
df_res$label[abs(df_res$residual) >= 1] <- TRUE
df_res$gene <- paste0("italic('",df_res$gene,"')")
ggplot(df_res, aes(x = coef_hu, y = coef_ms, label = gene)) +
  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +        # draw line from point to line
  geom_point(aes(fill = abs(residuals), size = abs(residuals)), shape = 21, colour = "grey20") +  # size of the points
  scale_fill_viridis_c(option = "plasma") +
  theme_bw() + 
  geom_text(hjust = -0.2, nudge_x = 0.05, data = df_res[df_res$label,], parse = TRUE) 
ggsave(paste0("plots/",dirsave,"/metaclustering/residual_plot_ductal.pdf"), width = 10, height = 8,  useDingbats = FALSE)
```

CLU and KRT8 are significantly upregulated in the mouse ductal cells

CLU:
* https://cancerdiscovery.aacrjournals.org/content/9/8/1102
* https://www.cell.com/cms/10.1016/j.cels.2016.08.011/attachment/9a6dd100-d0d2-44a3-84ad-aac5f0d9c862/mmc1


### Alpha

```{r Intepretability-alpha}
i <- which(combinations$g1 == "alpha_mouse" & combinations$g2 == "alpha_human")
df$tmp <- "bg"
df$tmp[df$g == combinations$g1[i]] <- "g1"
df$tmp[df$g == combinations$g2[i]] <- "g2"

design <- model.matrix(~  0 + tmp + b + detrate, data = df) # design  
contrast_m <- makeContrasts(contrasts = c("tmpg1-tmpbg", "tmpg2-tmpbg"), levels = design) # contrast

logCPM <- cpm(dge, log = TRUE, prior.count = 3)
fit <- lmFit(logCPM, design)
group_fit <- contrasts.fit(fit, contrast_m)
group_fit <- eBayes(group_fit, trend = TRUE, robust = TRUE)

df_res <- data.frame(gene = rownames(group_fit), coef_hu = coef(group_fit)[,2], coef_ms = coef(group_fit)[,1])
fit <- lm(coef_ms ~ coef_hu, data = df_res) # fit the model
df_res$predicted <- predict(fit)   # Save the predicted values
df_res$residuals <- residuals(fit) # Save the residual values
df_res$label <- FALSE
df_res$label[abs(df_res$residual) >= 1] <- TRUE
df_res$gene <- paste0("italic('",df_res$gene,"')")
ggplot(df_res, aes(x = coef_hu, y = coef_ms, label = gene)) +
  geom_smooth(method = "lm", se = FALSE, color = "lightgrey") +        # draw line from point to line
  geom_point(aes(fill = abs(residuals), size = abs(residuals)), shape = 21, colour = "grey20") +  # size of the points
  scale_fill_viridis_c(option = "plasma") +
  theme_bw() + 
  geom_text(hjust = -0.2, nudge_x = 0.06, data = df_res[df_res$label,], parse = TRUE) 

ggsave(paste0("plots/",dirsave,"/metaclustering/residual_plot_alpha.pdf"), width = 10, height = 8, useDingbats = FALSE)
```


## Final clustering


```{r pipeline2-final-clustering-match-names}
df_ari$runtime[df_ari$method == "ours_assisted"] <- df_ari$runtime[df_ari$method == "ours_assisted"] + system.time({
  hc <- hclust(as.dist(1-(dist_coef + t(dist_coef)))/2)
  hcluster <- cutree(hc, h = 0.45)
  df_merge <-  data.frame(initial_clusters = names(hcluster),
                          final_clusters = hcluster)
  
  seu$inicluster <- metadata$label
  seu$final_cluster <- df_merge$final_cluster[match(seu$inicluster,df_merge$initial_clusters)]
  seu$final_cluster[is.na(seu$final_cluster)] <- seu$inicluster[is.na(seu$final_cluster)]
})[3]

# record ARIs
df_ari$ARI[df_ari$method == "ours_assisted"] <- mclust::adjustedRandIndex(seu$final_cluster, seu$Group)
df_ari$batch_ARI[df_ari$method == "ours_assisted"] <- mclust::adjustedRandIndex(seu$final_cluster, seu$Batch)
clustering_res$ours_assisted <- seu$final_cluster[match(clustering_res$cell, colnames(seu))]
rm(seu_list)

knitr::kable(table(seu$final_cluster, seu$Group))
```

```{r cross-species-agreement-heatmap}
groups <- c("alpha","beta","delta", "gamma","ductal","endothelial", "activated_stellate", "quiescent_stellate", "macrophage")
idx1 <- paste0(groups, "_human")
idx2 <- paste0(groups, "_mouse")
tmp <- dist_coef + t(dist_coef)
diag(tmp) <- 1
# pdf("plots/pancreas_twospecies/metaclustering/similarity_matrix.pdf")
pheatmap::pheatmap(
  tmp[idx1, idx2],
  color = viridis::inferno(10),
  border_color = NA,
  display_numbers = TRUE,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  width = 7,
  height = 5,
  cellwidth = 25,
  cellheight = 25
)
# dev.off()
```


```{r pipeline2-final-clustering-network, fig.width=10, fig.height=10}
df <- data.frame(g = metadata$ground_truth[select],
                 b = metadata$batch[select], ## batch
                 c = metadata$label[select], stringsAsFactors = F) ## label

df$combination <- paste0(df$g, "-", df$c)
freq <- table(df$combination)
df$freq <- freq[match(df$combination, names(freq))]
df <- df[order(df$freq, decreasing = TRUE),]
df <- unique(df)

N <- length(unique(df$g))

edges <- data.frame(from = combinations$g1, to = combinations$g2, weight = NA)

tmp <- dist_coef + t(dist_coef)
for(i in 1:nrow(edges)) {
  edges$weight[i] <- tmp[rownames(tmp) == edges$from[i], colnames(tmp) == edges$to[i]]
}

edges$weight[edges$weight < 0] <- 0
edges <- edges[edges$weight > 0, ]
net <- graph_from_data_frame(edges, directed = FALSE)
E(net)$width <- 2^(E(net)$weight * 7)
vg_names <- attr(V(net), "names")
df_cols <- data.frame(group = unique(df$g),
                      col = col_vector[1:length(unique(df$g))], stringsAsFactors = FALSE)
df$col <- df_cols$col[match(df$g, df_cols$group)]

V(net)$color <- df$col[match(vg_names, df$c)]
V(net)$frame.color <- "#777777"
V(net)$size <- 8
V(net)$label.family <- "Helvetica"

plot(net);legend(x=-1.5, y=-1.1, df_cols$group, pch=21,
       col="#777777", pt.bg=df_cols$col, pt.cex=2, cex=1, bty="n", ncol=1)
```

```{r pipeline2-hirerchical-tree}
plot(hclust(as.dist(1-(dist_coef + t(dist_coef)))/2))
```

# Summary

```{r save-results}
# Adjusted Rand index
write.csv(df_ari, paste0("plots/ari/",dirsave,"_ari.csv"), row.names = FALSE)
saveRDS(clustering_res, paste0("rdata/",dirsave,"/clustering_res_metaclustering.rds"))

knitr::kable(df_ari[1:2,])
```

# Technical

```{r sessionInfo}
sessionInfo()
```


